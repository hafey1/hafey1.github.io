<!DOCTYPE html>
<html>    
    <head>
        
        <title> Robert Niggebrugge CofC CSCI 362 Fall 2020 Blog </title>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap"rel="stylesheet"> 
        <link type="text/css" rel="stylesheet" href="css/index.css">
        <script src="script.js"></script>
        
    </head> 
        <body>
            <h1 class="blogentry">Assignment 1: Chapter 1 Excercise</h1>
            <p class="blogentry" > Today's entry is specific to some questions regarding reading the Textbook called "Software Engineering" 10 edition by Ian Sommerville. One quick fact that I liked. Software Engineering as a concept did not exist until 1968 when it was brought up to solve the so called software crisis. Experts began to notice what is very clear today, software development on a large scale does not work without standardized tools, notation, or practices. </p>
            <hr>
            <h3> Excercise Questions </h3>
            <p class="blogentry">
            1.3) What are the four important attributes that all professional software should possess?  Suggest four other attributes that may sometimes be significant.
                <li class="blogentry"> The book lists acceptability, dependability and security, efficiency, and maintainability as 4 important attributes of good and professional software. Each of these are very obvious when considering the goal of scalability. Acceptability allows for the consideration of reaching the most users possible. Dependability and security is rather obvious because a failure or a breach in a large scale system has massive costs for all people who use the system. Efficiency is a pillar of any coded solution to a problem because time is money. Lastly, Maintainability is probably the most overlooked quality, but just as necessary. It is key because it not only allows a software to change to a customers demands but it also involves each other of the three attributes. Computer systems and security are constantly being upgraded and a software developed must account for these changes over time as well. Some other important attributes of software in my opinion are readability, well-documented, future-oriented, and modularized. Readability and well-documented is critical to continuing support of code when a software has a long lifespan. These are both closely related but differ in the fact that Readability refers to having the executable code using meaningful language that helps understanding while well-documentated code allows for more detailed info about the process for a maintainer of the codebase. Future-oriented means while the customer is always right, good software should always be able to retooled to to fit the customers needs, or should be able to be quickly modified because of forethought by the developers in consideration of possible problems that could arise. Lastly, while modularization is already quite popular, it still bears repeating. This is one of the key ways that software and its development is able to quickly shift priorities and ensure maintainability.</li>
            </p>
            <hr>
            <p class="blogentry">
            1.8: Discuss whether professional software engineers should be licensed in the same way as doctors or lawyers.
                
                    <li class="blogentry"> I do not believe that software engineers should be licensed in the same way as doctors or lawyers. The most apparent reason is because the variance in the goals that these professions seek to achieve is vastly different. This is not to say that one is more complex but there are more techniques, tools, and localized goals in software developement are than the other professions. An example could be comparing two examples from each category that have the same job title. Two defense attorney, two cardiologists, and two backend developers. The defense attorneys and cardiologists could have some personal differences in the specifics in how they do their job correctly but there is a consistent and explicit format to their processes. However the only thing that could be the same between the backend developers is that they handle databases. They could use very different tools, languages, frameworks, development processes. If they were to swap jobs for a day, it is very possible that they would be useless. In the same vein, the frequency of change between practices and tools all these jobs uses is no where near the same. Software Engineering almost revolutionizes every five to ten years and the same can not be said of the former two occupations.
                    </li>
                
            </p>
            <hr>
            <p style="blogentry">
            1.9: For each of the clauses in the ACM/IEEE Code of Ethics shown in Figure 1.4, propose an appropriate example that illustrates that clause.    
                <ol class="blogentry">
                    <li > Public: A software engineer that is building an application for a bank must properly secure its codebase so that it cannot be taken advantage of for the general interest of the public.
                    </li>
                    <li> Client and Employer: If an engineer did not act in the best interest of the client, employer, and general public they could not be trusted to build systems that handle sensitive information.
                    </li>
                    <li> Product: If a product is not built up to the highest standards knowingly, the engineer would be solely responsible for the failure of the product and would adversely effect the client, employer, and/or the general public. 
                    </li>
                    <li> Judgement: Software engineers are often consultants/ make important calls for a client based on their experience and knowledge. Being unbiased is critical to creating the best product.
                    </li>
                    <li> Management: A management that does not use ethical practices will cut corners and abuse their staff. Which directly effects the quality of the work and the final product.
                    </li>
                    <li> Profession: Software Engineering could not be taken seriously and would be considered unlawful if the profession consistently acted against the public interest.
                    </li>
                    <li> Colleagues: A work environment that does not contain colleagues that are fair and supportive again hinders the bottom line. It effects the quality of the work.
                    </li>
                    <li> Self: Software Engineering is a unique field that requires constant learning throughout the entire span of a career. Languages and tools constantly evolve and the life of an engineer is to adapt to these changes.
                    </li>
                </ol>
            </p>
            <hr>
            <p class="blogentry">
            1.10: To help counter terrorism, many countries are planning or have developed computer systems that track large numbers of their citizens and their actions.  Clearly, this has privacy implications.  Discuss the ethics of working on the development of this type of system.
                
                    <li class="blogentry"> There is a very fine line that a software engineer would have to walk to ethically create a system such as this. One would have to take every chance to properly assess the balance between the concern for privacy vs security for the general public. Generally because of the large scale nature of this system it must be securely coded and maintained. But ethical concerns will arise in the design of such a system. It is inherently a system that infringes upon the general public in order to help them. And more worrisome is the issue of the system becoming compromised. If this were to happen it would massively harm the general public. In order to ethically create such a system a software engineer would have to have a goal to create methods of identification that preserve anonymity to a large degree while also at the same time allowing the system enough information to correctly identify threats. For an individual software engineer, they would have to define the point exactly where they deem their work unethical. For this example a reasonable point could be if they could not create the system without hoarding large amounts of aggregated data of individuals. Upon realizing this they would have to voice their concerns and if necessary exit the project.
                    </li>
                
            </p>
    </body>
</html>